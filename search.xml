<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>常见排序算法</title>
      <link href="/2022/07/16/chang-jian-pai-xu-suan-fa/"/>
      <url>/2022/07/16/chang-jian-pai-xu-suan-fa/</url>
      
        <content type="html"><![CDATA[<h2 id="常见排序"><a href="#常见排序" class="headerlink" title="常见排序"></a><strong>常见排序</strong></h2><ul><li><h4 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a><strong>冒泡排序</strong></h4></li><li><p>相邻的两个数比较，如果arr[i]&gt;arr[i+1],就交换两个数的位置，只需要循环n-1次，内部比较交换n-1-i次</p></li><li><pre><code class="java">public static void sort(int[] arr) &#123;     for (int i = 0; i &lt; arr.length-1; i++) &#123;         for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123;             if (arr[j] &gt; arr[j + 1]) &#123;                 int temp = arr[j];                 arr[j] = arr[j + 1];                 arr[j + 1] = temp;             &#125;         &#125;     &#125; &#125;  <pre class="line-numbers language-none"><code class="language-none">- 优化：定义一个flag标记，如果是有序的就不用冒泡了，直接break；- #### **选择排序**- 定义一个min，minIndex，从数组的第arr[i]个数,依次和其后面的数比较，较小的那个赋值给min，下标赋值给minIndex，然后两个数位置交换，arr[minIndex]&#x3D;arr[i],arr[i]&#x3D;min- &#96;&#96;&#96;java      public static void select(int[] arr) &#123;          for (int i &#x3D; 0; i &lt; arr.length - 1; i++) &#123;              int min &#x3D; arr[i];              int minIndex &#x3D; i;              for (int j &#x3D; i + 1; j &lt; arr.length; j++) &#123;                  if (min &gt; arr[j]) &#123;                      min &#x3D; arr[j];                      minIndex &#x3D; j;                  &#125;              &#125;              if (i !&#x3D; minIndex) &#123;                  arr[minIndex] &#x3D; arr[i];                  arr[i] &#x3D; min;              &#125;          &#125;      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a><strong>插入排序</strong></h4></li><li><p>从数组的第二个数开始插入，定义Index记录当前要插入的数的下标，value记录当前的值。</p></li><li><p>如果这个数比前一个数小则将这个数的位置的值赋值为前一个数 arr[insertIndex] &#x3D; arr[insertIndex - 1]，下标减1。依次进行插入。最后将记录的当前value值赋给最后插入的位置。</p></li><li><pre><code class="java">public static void insert(int[] arr) &#123;      for (int i = 1; i &lt; arr.length; i++) &#123;          int insertIndex = i;          int insertValue = arr[i];          while (insertIndex &gt; 0 &amp;&amp; insertValue &lt; arr[insertIndex - 1]) &#123;              arr[insertIndex] = arr[insertIndex - 1];              insertIndex--;          &#125;          arr[insertIndex] = insertValue;      &#125;  &#125;<pre class="line-numbers language-none"><code class="language-none">- #### **希尔排序**- 就是插入排序，原理一样，只是多了一个步长，跳着比较，不是挨着一个一个插入- &#96;&#96;&#96;java      public static void shell(int[] arr) &#123;          &#x2F;&#x2F;步长gap          for (int gap &#x3D; arr.length &#x2F; 2; gap &gt; 0; gap &#x2F;&#x3D; 2) &#123;              for (int i &#x3D; 0; i &lt; arr.length; i++) &#123;                  int insertIndex &#x3D; i;                  int insertValue &#x3D; arr[i];                  while (insertIndex - gap &gt;&#x3D; 0 &amp;&amp; insertValue &lt; arr[insertIndex - gap]) &#123;                      arr[insertIndex] &#x3D; arr[insertIndex - gap];                      insertIndex -&#x3D; gap;                  &#125;                  arr[insertIndex] &#x3D; insertValue;              &#125;          &#125;      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></code></pre></li><li><h4 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a><strong>快速排序</strong></h4></li><li><p>定义两个指针l和r，首先保证最右边的数大于最左边的数，先移动右边的指针，直到arr[r]小于左边的数，再移动左边的指针，直到arr[l]大于最左边的数，即保证右边的所有数都大于最左边，左边的数都小于左边。最后l指针和r指针移到同一位置时，交换该位置和最左边那个数，如果两个指针不在同一位置就交换这两个位置，再递归再次快速排序</p></li><li><pre><code class="java">public static void quick(int[] arr, int left, int right) &#123;     if (left &gt;= right) &#123;         return;     &#125;     int l = left;     int r = right;     while (l &lt; r) &#123;         //先右边指针移动         while (l &lt; r &amp;&amp; arr[r] &gt;= arr[left]) &#123;             r--;         &#125;         while (l &lt; r &amp;&amp; arr[l] &lt;= arr[left]) &#123;             l++;         &#125;         if (l == r) &#123;             int temp = arr[r];             arr[r] = arr[left];             arr[left] = temp;         &#125; else &#123;             int temp = arr[r];             arr[r] = arr[l];             arr[l] = temp;         &#125;     &#125;     quick(arr, left, l - 1);     quick(arr, r + 1, right); &#125;</code></pre></li></ul>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JVM</title>
      <link href="/2022/07/16/guan-yu-jvm/"/>
      <url>/2022/07/16/guan-yu-jvm/</url>
      
        <content type="html"><![CDATA[<h2 id="初识JVM"><a href="#初识JVM" class="headerlink" title="初识JVM"></a><strong>初识JVM</strong></h2><ul><li><h4 id="jvm的位置-操作系统"><a href="#jvm的位置-操作系统" class="headerlink" title="jvm的位置:操作系统"></a>jvm的位置:操作系统</h4></li><li><h4 id="jvm的体系结构："><a href="#jvm的体系结构：" class="headerlink" title="jvm的体系结构："></a><strong>jvm的体系结构：</strong></h4></li><li><p>栈区存地址，引用变量(别名&#x3D;堆内存中的首地址)，堆区存数据，new创建的对象和数组</p><p><img src="C:/Users/rhl/AppData/Roaming/Typora/typora-user-images/image-20220525115342185.png" alt="image-20220525115342185"></p></li><li><p><img src="https://img-blog.csdn.net/20180621164446655?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dhbmRlcmx1c3RMZWU=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="img"></p></li><li><h4 id="类加载器："><a href="#类加载器：" class="headerlink" title="类加载器："></a><strong>类加载器：</strong></h4><p><strong>什么是类加载</strong>：”.java”拓展名类文件，经过编译器编译成”.class”文件，”.class”文件中保存着Java代码经转换后的虚拟机指令，当需要使用某个类时，虚拟机会加载对应”.class”文件，并创建对应的class对象，将class文件加载到虚拟机的内存</p><p><strong>三个类加载器：****启动（Bootstrap）类加载器</strong>，<strong>扩展（Extension）类加载器</strong>，<strong>系统（System）类加载器</strong></p><p><strong>双亲委派模式</strong>：</p><p>一个类加载器收到了加载请求，不会自己先加载而是依次请求委托给父类加载器。直到顶层的加载器加载</p><p>这个机制目的是为了避免重复类的加载，防止核心类被任意替换</p><p><img src="C:/Users/rhl/AppData/Roaming/Typora/typora-user-images/image-20220525113250149.png" alt="image-20220525113250149"></p></li><li><h4 id="Native关键字："><a href="#Native关键字：" class="headerlink" title="Native关键字："></a>Native关键字：</h4><p>不会调用Java自带的方法，在类加载的时候进入本地方法栈（Native Method Stack），在执行引擎执行的时候加载本地库，调用本地方法接口。</p></li><li><h4 id="寄存器"><a href="#寄存器" class="headerlink" title="寄存器"></a><strong>寄存器</strong></h4></li><li><h4 id="方法区：被所有线程共享，不安全"><a href="#方法区：被所有线程共享，不安全" class="headerlink" title="方法区：被所有线程共享，不安全"></a><strong>方法区：</strong>被所有线程共享，不安全</h4><p>Class对象是放在堆区，类的元数据放在方法区，方法区在元空间（MetaSpace），元空间是方法区的实现</p><p>静态变量+常量+类信息+运行时常量池存在方法区中，实例变量存在堆内存中</p></li><li><h4 id="栈区：线程私有"><a href="#栈区：线程私有" class="headerlink" title="栈区：线程私有"></a><strong>栈区：</strong>线程私有</h4></li><li><p>虚拟机栈：主要管理程序的运行，生命周期和线程同步，线程结束，栈内存释放，不存在垃圾回收机制</p></li><li><p>每个方法被执行的时候都会同时创建一个栈帧用于存储局部变量表、操作数栈、动态链接、返回方法地址等信息</p></li><li><h4 id="堆区（Heap-Area）：被所有线程共享，不安全"><a href="#堆区（Heap-Area）：被所有线程共享，不安全" class="headerlink" title="堆区（Heap Area）：被所有线程共享，不安全"></a><strong>堆区（Heap Area）：</strong>被所有线程共享，不安全</h4></li><li><p>结构：jdk1.8之后永久代变为元空间</p></li><li><p><img src="https://img2018.cnblogs.com/blog/955092/201903/955092-20190313165427522-1253660306.jpg" alt="img"></p></li><li><p><img src="http://i2.51cto.com/images/blog/201808/21/b116170771ecb3117ae7fead03fcaa0d.png?x-oss-process=image/watermark,size_16,text_QDUxQ1RP5Y2a5a6i,color_FFFFFF,t_100,g_se,x_10,y_10,shadow_90,type_ZmFuZ3poZW5naGVpdGk=" alt="Java堆内存又溢出了！教你一招必杀技"></p></li><li><h4 id="GC：在堆区执行"><a href="#GC：在堆区执行" class="headerlink" title="GC：在堆区执行"></a><strong>GC</strong>：在堆区执行</h4></li><li><p><strong>引用计数法：</strong>判断是否可以回收，这种方法不常用</p></li><li><p><strong>可达性分析法</strong>: 判断是否可以回收</p></li><li><p>这个算法的基本思想是通过一系列称为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链，当一个对象到GC Roots没有任何引用链（即GC Roots到对象不可达）时，则证明此对象是不可用的</p></li><li><p><strong>复制算法：</strong>不会产生内存碎片，但会浪费内存空间</p><p>from区，和to区，要有一个为空，为空的是to区，</p></li><li><p><strong>标记清除法：</strong>会产生大量内存碎片，执行效率不高</p></li><li><p><strong>标记压缩法：</strong>通常用在老年区</p></li><li><p><strong>分代收集算法：</strong></p></li><li><p>针对不同区采用不同的算法</p></li><li><p><strong>JMM（Java内存模型）</strong></p></li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2022/07/15/hello-world/"/>
      <url>/2022/07/15/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo generate<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ hexo deploy<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
